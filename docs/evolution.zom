//! A proof of concept of a Reference Counted smart pointer in Zom,
//! it doesn't actually compiles but it shows which way the Zom Lang
//! evolve. The standard library as showed in this file may not be
//! like that in the future.

// Imports, they are 'Import Item'
import std.mem;
import std.prelude.*;

// A struct with a generic 'T' that may not implement 'Sized'
struct RcInner[T: ?Sized] {
    count: usize,
    value: T,
}

// Implementation with generic 'T'
impl[T: ?Sized] RcInner[T] {
    func inc_count(*self) void {
        self->count += 1;
    }

    func dec_count(*self) void {
        self->count -= 1;
    }
}

// Another struct with generic 'T' that may not implement 'Sized'.
// This struct is publicly avalaible, you just need to import it.
pub struct Rc[T: ?Sized] {
    inner: *RcInner[T],
}

impl[T: ?Sized] Rc[T] {
    pub func new(value: T) Self {
        Self {
            inner: &RcInner {
                count: 1,
                value: mem.alloc[T](),
            },
            alloc,
        }
    }

    // a public function that takes an argument named 'self' that is a pointer.
    // '*self' is equivalent to 'self: *Self'.
    pub func count(*self) usize {
        return self->inner()->count
    }
}

// Implementation of the trait 'Deref' for every Rc[T]
impl[T: ?Sized] Deref for Rc[T] {
    type Target = T;

    func deref(*self) *Target {
        &self->inner()->value
    }
}

impl[T: ?Sized] Clone for Rc[T] {
    func clone(*self) Self {
        self->inner()->inc_count();
        return Self {
            inner: self->inner
        }
    }
}

// This trait is kinda special, it's called when a variable doesn't live anymore
// inspired by C++ RAII and Rust OBRM.
impl[T: ?Sized] Drop for Rc[T] {
    func drop(*self) void {
        self->inner->dec_count();
        if self->count() == 0 {
            // No more references, free the object
            mem.free[T](self->deref());
        }
    }
}

// this is a test, it's like a function, it's called when it's build in test mode.
test "Rc creation" {
    // ...
}

// example of a function taking a function pointer.
pub func map[T](list: []T, f: func (T) T) void {
    //                        ^^^^^^^^^^ function pointer type
    //                        takes an argument of type 'T' and returns of type 'T'
    for e in &list {
        *e = f();
    }
}

test "map function" {
    var list = {1, 2, 3, 4, 5};
    //         ---------------
    //         array / slice expression

    map(list, [e] e * 2);
    //        ^^^^^^^^^
    //        closure expression,
    //        arguments are in brackets, without types annoted, because types are in the type of the function pointer.
    //        after the args, their is an expression, it can just be a simple expression or an block expression if more logic is needed.

    // list = {2, 4, 6, 8, 10}

    const hw: func(*const str, u32) = [name, fav_number] {
        println("Hello {}! Your favorite number is {}  ", _{name, fav_number});
        //                                                ^^^^^^^^^^^^^^^^^^^ anonymous struct => tuple
    };

    hb()
}

func println(comptime fmt: *const str, args: anytype = _{}) void {
    //                                 --------------^^^^^ argument defaulted to a zero-sized, annonymous type.
    //                                 Like that you can just call this function with `println("Hello world!")`
    //                                 instead of `println("Hello world!", _{})`
    // some compile-time logic, TODO: explain / write this function
}
